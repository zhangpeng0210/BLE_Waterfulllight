{"version":3,"file":"index.esm.js","sources":["../src/core/log.ts","../src/core/utils.ts","../src/core/parseFun.ts","../src/core/error.ts","../src/core/generator.ts","../src/core/condition.ts","../src/core/parse.ts","../src/core/formatFun.ts","../src/core/format.ts","../src/index.ts"],"sourcesContent":["const callbacks: LogFunc[] = [];\n\nexport const onLog = (cb: LogFunc) => {\n  callbacks.push(cb);\n};\nexport const offLog = (cb: LogFunc) => {\n  const index = callbacks.indexOf(cb);\n  if (index >= 0) {\n    callbacks.splice(index, 1);\n  }\n};\n\nexport const emitLog = (data: LogData) => {\n  if (process?.env?.NODE_ENV === 'development') {\n    console.warn('警告：', data.message);\n    console.warn('相关数据：', data.data);\n  }\n  callbacks.forEach((cb: LogFunc) => {\n    cb(data);\n  });\n};\n","import { padStart, get } from 'lodash';\n\n/**\n * 返回属性默认值\n * @param config 属性配置\n * @param result 当前同级节点数据\n * @returns\n */\nexport const getItemDefault = (config: DpMapItem, result: any) => {\n  const { defaultValue, type = 'number', bytes = 1, extension } = config;\n  if (typeof defaultValue !== 'undefined') {\n    return defaultValue;\n  }\n  const length = getBytes(config, result) * 2;\n  switch (type) {\n    case 'number':\n    case 'numberBySeparate':\n      if (extension) {\n        const { min } = extension;\n        return typeof min === 'undefined' ? 0 : min;\n      }\n      return 0;\n    case 'string':\n      return padStart('00', length, '0');\n    case 'boolean':\n      return false;\n    case 'enum':\n      if (extension) {\n        const { range } = extension;\n        return Array.isArray(range) && range.length ? range[0] : 0;\n      }\n      return 0;\n    case 'week':\n      return [0, 0, 0, 0, 0, 0, 0];\n    case 'bit':\n      return [...new Array(length).keys()].map(() => 0);\n    case 'child':\n      return {};\n    default:\n      return;\n  }\n};\n\n/**\n * 获取属性所占字节数(返回的bytes不能为0)\n * @param config 配置\n * @param res 当前同级数据节点\n * @returns 属性所占字节数\n */\nexport const getBytes = (config: DpMapItem, res: any): number => {\n  const { bytes = 1 } = config;\n  let temp = bytes;\n  if (Array.isArray(bytes) || typeof bytes === 'string') {\n    temp = get(res, bytes, 1);\n  }\n  return (temp as number) || 1;\n};\n","import { emitLog } from './log';\nimport { getBytes } from './utils';\n\nexport const parseNumber = (generator: MyGenerator, config: DpMapItem, result: any) => {\n  const { extension } = config;\n  const value = generator.nextNumber(config, result);\n  if (extension) {\n    const { min = -Infinity, max = Infinity } = extension;\n    return Math.max(Math.min(value, max), min);\n  }\n  return value;\n};\n\nexport const parseString = (generator: MyGenerator, config: DpMapItem, result: any) => {\n  return generator.next(config, result);\n};\n\nexport const parseBoolean = (generator: MyGenerator, config: DpMapItem, result: any) => {\n  return generator.nextBoolean(config, result);\n};\n\nexport const parseEnum = (generator: MyGenerator, config: DpMapItem, result: any) => {\n  const { extension, name } = config;\n  const enumValue = generator.nextNumber(config, result);\n  if (extension) {\n    // 是否有扩展值，则检验是否值标准\n    const { range } = extension;\n    if (Array.isArray(range) && range.length) {\n      if (range.includes(enumValue)) {\n        return enumValue;\n      } else {\n        // 提示校验失败，返回了枚举第一个值\n        emitLog({\n          type: 'warning',\n          message: `解析到属性【${name}】时，得到的值${enumValue}未在可枚举范围内`,\n          data: { [name]: enumValue },\n        });\n        return range[0];\n      }\n    }\n  }\n  return enumValue;\n};\n\nexport const parseBit = (generator: MyGenerator, config: DpMapItem, result: any) => {\n  return generator.nextBits(config, result);\n};\n\nexport const parseWeek = (generator: MyGenerator, config: DpMapItem, result: any) => {\n  return parseBit(generator, config, result).slice(0, 7);\n};\n\nexport const parseCustom = (generator: MyGenerator, config: DpMapItem, result: any) => {\n  const { parse, name } = config;\n  const value = generator.next(config, result);\n  const num = parseInt(value, 16);\n  if (typeof parse === 'function') {\n    return parse(num, value);\n  }\n  // 提示配置有误\n  emitLog({\n    type: 'warning',\n    message: `解析自定义类型属性【${name}】时，检测到未配置 parse 函数`,\n    data: {\n      [name]: num,\n    },\n  });\n  return num;\n};\n\nexport const parseNumberBySeparate = (generator: MyGenerator, config: DpMapItem, result: any) => {\n  const { extension, numType = 'hex' } = config;\n  const bytes = getBytes(config, result);\n  if (bytes === 1) {\n    return generator.nextNumber(config, result);\n  }\n  const value = generator.next(config, result);\n  let total = 0;\n  for (let i = 0; i < value.length; i += 2) {\n    const num =\n      parseInt(value.slice(i, i + 2), numType === 'dec' ? 10 : 16) * 10 ** (value.length - 2 - i);\n    total += num;\n  }\n  if (extension) {\n    const { min = -Infinity, max = Infinity } = extension;\n    return Math.max(Math.min(total, max), min);\n  }\n  return total;\n};\n","export default class TransformError {\n  /**\n   * 解析错误码，表示已经解析到末尾，没有可再解析的数据\n   */\n  static ALLREADY_TO_END = 'endError';\n  /**\n   *\n   */\n  static UNKOWN_CONDITION = 'unkownConditionError';\n\n  code: string;\n  msg: string;\n  constructor(code: string, msg: string) {\n    this.code = code;\n    this.msg = msg;\n  }\n}\n","import { padStart } from 'lodash';\nimport TransformError from './error';\nimport { getBytes } from './utils';\n\nfunction* subStrMyGenerator(dpValue: string): Iterator<string, string, number> {\n  let start = 0;\n  let result = '';\n  let length;\n  for (; true; ) {\n    length = (yield result) * 2;\n    result = dpValue.substr(start, length);\n    if (start + length >= dpValue.length) {\n      break;\n    }\n    start += length;\n  }\n  return result;\n}\n\n/**\n * 截取字符串\n * @param dpValue\n * @returns\n */\nexport const createMyGenerator = (dpValue: string): MyGenerator => {\n  const ganerator = subStrMyGenerator(dpValue);\n  ganerator.next();\n  let isEnd = dpValue.length === 0; // 修复无值时返回错误数据\n\n  // 截取数据\n  const next = (config: DpMapItem, result: any): string => {\n    if (isEnd) {\n      // 结束抛出错误\n      throw new TransformError(TransformError.ALLREADY_TO_END, '已经解析到末尾，无法再解析');\n    }\n    const { storageType = 'be' } = config;\n    const bytes = getBytes(config, result);\n    const { value, done } = ganerator.next(bytes);\n    isEnd = done;\n    if (storageType === 'le') {\n      // 小端格式\n      const result: string[] = [];\n      for (let i = 0; i < value.length; i += 2) {\n        result.splice(0, 0, value.slice(i, i + 2));\n      }\n      return result.join('');\n    }\n    return value;\n  };\n\n  const nextBits = (config: DpMapItem, res: any) => {\n    const { numType = 'hex', bitType = 'right' } = config;\n    const value = next(config, res);\n    const radix = numType === 'dec' ? 10 : 16;\n    const result: Array<1 | 0> = [];\n    for (let i = 0; i < value.length; i += 2) {\n      const temp = parseInt(value.slice(i, i + 2), radix);\n      const bits = padStart(temp.toString(2), 8, '0')\n        .split('')\n        .map(v => Number(v)) as Array<1 | 0>;\n      // 是否为从右边取数据\n      if (bitType === 'right') {\n        bits.reverse();\n      }\n      result.push(...bits);\n    }\n    return result;\n  };\n\n  // 截取数据并转化为一个十进制\n  const nextNumber = (config: DpMapItem, result: any) => {\n    const { numType = 'hex' } = config;\n    return parseInt(next(config, result), numType === 'dec' ? 10 : 16);\n  };\n  // 截取数据并转化为一个布尔值\n  const nextBoolean = (config: DpMapItem, result: any) => {\n    return Boolean(nextNumber(config, result));\n  };\n\n  const hasNext = () => {\n    return !isEnd;\n  };\n  return {\n    next,\n    nextNumber,\n    nextBoolean,\n    nextBits,\n    hasNext,\n  };\n};\n","import { get } from 'lodash';\n\n/**\n * 获取判断条件配置属性的值\n * @param condition 逻辑判断配置数据\n * @param result 当前已解析的数据\n * @param currentResult 当前同级节点的数据\n * @returns\n */\nconst fetchConditionTargetValue = (condition: Condition, result: any, currentResult: any) => {\n  const { findType, prop } = condition;\n  switch (findType) {\n    case 'root':\n      return get(result, prop);\n    case 'current':\n      return get(currentResult, prop);\n    default:\n      return get(result, prop) ?? get(currentResult, prop);\n  }\n};\n\n/**\n * 执行判断逻辑操作\n * @param condition 逻辑判断配置数据\n * @param result 当前已解析的数据\n * @param currentResult 当前同级节点的数据\n * @returns {boolean} 判断结果\n */\nconst conditionOperate = (condition: Condition, result: any, currentResult: any): boolean => {\n  const { operation = 'eq', value } = condition;\n  const target = fetchConditionTargetValue(condition, result, currentResult);\n  switch (operation) {\n    case 'eq':\n      return target === value;\n    case 'neq':\n      return target !== value;\n    case 'lt':\n      return target < value;\n    case 'lte':\n      return target <= value;\n    case 'gt':\n      return target > value;\n    case 'gte':\n      return target >= value;\n    default:\n      // 无法实别的判断类型，返回false\n      return false;\n  }\n};\n\n/**\n * 判断字段是否需要解析\n * @param condition 判断条件\n * @param result 当前已解析数据\n * @param currentResult 当前同级节点的数据\n * @returns\n */\nexport const transformEnabled = (\n  condition: Condition | CompositeCondition,\n  result: any,\n  currentResult: any\n): boolean => {\n  if (condition) {\n    // 是否为复合操作\n    if ('conditions' in condition) {\n      const { conditions, type } = condition;\n      if (type === 'or') {\n        return conditions.some(cond => transformEnabled(cond, result, currentResult));\n      }\n      return conditions.every(cond => transformEnabled(cond, result, currentResult));\n    } else {\n      // 判断\n      return conditionOperate(condition, result, currentResult);\n    }\n  }\n\n  // 无配置时，返回可解析\n  return true;\n};\n","import { get } from 'lodash';\nimport {\n  parseBit,\n  parseBoolean,\n  parseCustom,\n  parseEnum,\n  parseNumber,\n  parseString,\n  parseWeek,\n  parseNumberBySeparate,\n} from './parseFun';\nimport { createMyGenerator } from './generator';\nimport { transformEnabled } from './condition';\nimport { getItemDefault } from './utils';\nimport { emitLog } from './log';\n\nconst parseTypes = {\n  number: parseNumber,\n  string: parseString,\n  boolean: parseBoolean,\n  bit: parseBit,\n  week: parseWeek,\n  enum: parseEnum,\n  custom: parseCustom,\n  numberBySeparate: parseNumberBySeparate,\n  default: parseNumber,\n};\n\n/**\n * 解析子节点字段\n * @param generator 截取数据生成器\n * @param config 配置\n * @param rootResult 已解析根数据\n * @returns 解析字段值\n */\nconst transformChild = (generator: MyGenerator, config: DpMapItem, rootResult: any) => {\n  const { childMap } = config;\n  const childResult: any = {};\n  childMap.forEach(itemConfig => {\n    const { condition } = itemConfig;\n    if (transformEnabled(condition, rootResult, childResult)) {\n      const value = transformProp(generator, itemConfig, childResult, rootResult);\n      childResult[itemConfig.name] = value;\n    }\n  });\n  return childResult;\n};\n\n/**\n * 解析字段\n * @param generator 截取数据生成器\n * @param config 配置\n * @param result 已解析数据\n * @param rootResult 已解析根数据\n * @returns 解析字段值\n */\nconst transformProp = (generator: MyGenerator, config: DpMapItem, result: any, rootResult: any) => {\n  const { type = 'number', loop = false, limit, name } = config;\n  let max = 1;\n  // 处理循环情况\n  if (loop) {\n    // 是否限制循环次数\n    if (limit) {\n      // 是否由已解析的数据确认循环次数\n      if (typeof limit === 'string' || Array.isArray(limit)) {\n        max = get(result, limit, 0);\n      } else {\n        max = limit;\n      }\n    } else {\n      max = Infinity;\n    }\n  }\n  const values: any = [];\n  for (let i = 0; i < max; i++) {\n    if (generator.hasNext()) {\n      let value: any;\n      // 如果是子类型解析\n      if (type === 'child') {\n        value = transformChild(generator, config, rootResult);\n      } else {\n        // 其他数据类型处理\n        if (typeof parseTypes[type] === 'function') {\n          value = parseTypes[type](generator, config, result);\n        } else {\n          value = parseTypes.default(generator, config, result);\n        }\n      }\n      values.push(value);\n    } else {\n      // 解析失败，返回默认值\n      !values.length && values.push(getItemDefault(config, result));\n\n      // 提示解析有误\n      i === 0 &&\n        emitLog({\n          type: 'warning',\n          message: `解析到属性【${name}】时，发现已无可解析的数据，属性返回默认值`,\n          data: { [name]: loop ? values : values[0] },\n        });\n      break;\n    }\n  }\n\n  return loop ? values : values[0];\n};\n\n/**\n * 解析协议\n * @param config 总dp配置\n * @param dpValue 待解析的协议数据\n * @param result 已解析完成的数据\n */\nconst transform = (config: DpMap, dpValue: string, result: any) => {\n  // 当 dp 配置为列表数据时，并且 dp 值为 00， 则表示其为空列表；（原因为raw格式数据必须有下发1字节数据，不能传空数据）\n  if ((dpValue === '00' || !dpValue) && config[0]?.type === 'child' && config[0]?.loop) {\n    return [];\n  }\n  const generator = createMyGenerator(dpValue);\n  config.forEach((itemConfig: DpMapItem) => {\n    const { name, condition } = itemConfig;\n    if (transformEnabled(condition, result, result)) {\n      // 执行解析\n      const value = transformProp(generator, itemConfig, result, result);\n      result[name] = value;\n    }\n  });\n\n  return result;\n};\n\nexport const parse = (value: string, dpMap: DpMap) => {\n  return transform(dpMap, value, {});\n};\n","import { padStart } from 'lodash';\nimport { emitLog } from './log';\nimport { getBytes } from './utils';\n\nconst formatTo16 = (num: number, bytes = 1) => {\n  return padStart(Number(num).toString(16), bytes * 2, '0');\n};\n\nconst formatTo10 = (num: number, bytes = 1) => {\n  return padStart(Number(num).toString(), bytes * 2, '0');\n};\n\nconst formatValueByNumType = (num: number, bytes: number, numType: 'hex' | 'dec') => {\n  if (numType === 'dec') {\n    return formatTo10(num, bytes);\n  }\n  return formatTo16(num, bytes);\n};\n\nconst formatValueByStorage = (value: string, storageType: 'be' | 'le') => {\n  if (storageType === 'le') {\n    const result: string[] = [];\n    for (let i = 0; i < value.length; i += 2) {\n      result.splice(0, 0, value.slice(i, i + 2));\n    }\n    return result.join('');\n  }\n  return value;\n};\n\n/**\n * 格式化数值为字符串\n * @param num 值\n * @param config 属性配置\n * @param result 当前同级数据\n * @returns\n */\nexport const formatNumber = (num: number, config: DpMapItem, result: any) => {\n  const { extension, numType = 'hex', storageType = 'be' } = config;\n  const bytes = getBytes(config, result);\n  let value = num;\n  if (extension) {\n    const { min = -Infinity, max = Infinity } = extension;\n    value = Math.max(Math.min(value, max), min);\n  }\n  return formatValueByStorage(formatValueByNumType(value, bytes, numType), storageType);\n};\n\n/**\n * 将布尔值格式化为字符串\n * @param value 布尔值\n * @param config 属性配置\n * @param result 当前同级数据\n * @returns\n */\nexport const formatBoolean = (value: boolean, config: DpMapItem, result: any) => {\n  return formatNumber(Number(value), config, result);\n};\n\n/**\n * 将枚举值格式化为字符串\n * @param num 枚举值\n * @param config 属性配置\n * @param result 当前同级数据\n * @returns\n */\nexport const formatEnum = (num: number, config: DpMapItem, result: any) => {\n  const { extension, name } = config;\n  let value = num;\n  if (extension) {\n    // 是否有扩展值，则检验是否值标准\n    const { range } = extension;\n    if (Array.isArray(range) && range.length) {\n      if (range.includes(num)) {\n        value = num;\n      } else {\n        // 提示校验失败\n        emitLog({\n          type: 'warning',\n          message: `属性【${name}】的值${num}不在可枚举范围内`,\n          data: {\n            [name]: num,\n          },\n        });\n        //返回了枚举第一个值\n        value = range[0];\n      }\n    }\n  }\n  return formatNumber(value, config, result);\n};\n\n/**\n * 将位序列格式化为字符串\n * @param bits 位序列\n * @param config 属性配置\n * @param result 当前同级数据\n * @returns\n */\nexport const formatBit = (bits: number[], config: DpMapItem, res: any) => {\n  const { storageType = 'be', numType = 'hex', bitType = 'right' } = config;\n  const bytes = getBytes(config, res);\n  const result: string[] = [];\n  // 每8位一个字节\n  for (let i = 0; i < bytes; i++) {\n    const start = i * 8;\n    const end = (i + 1) * 8;\n    const byteBits = bits.slice(start, end);\n    // 数据是否准确\n    if (byteBits.length < 8) {\n      const moreCount = 8 - byteBits.length;\n      for (let j = 0; j < moreCount; j++) {\n        byteBits.push(0);\n      }\n    }\n\n    if (bitType === 'right') {\n      byteBits.reverse();\n    }\n\n    const value = parseInt(byteBits.join(''), 2);\n    result.push(formatValueByNumType(value, 1, numType));\n  }\n  return formatValueByStorage(result.join(''), storageType);\n};\n\n/**\n * 将星期格式化为字符串\n * @param bits 星期数据\n * @param config 属性配置\n * @param result 当前同级数据\n * @returns\n */\nexport const formatWeek = (bits: number[], config: DpMapItem, res: any) => {\n  return formatBit([...bits, 0], config, res);\n};\n\nexport const formatString = (value: string, config: DpMapItem, res: any) => {\n  const { storageType = 'be', name } = config;\n  const bytes = getBytes(config, res);\n  const targetLength = bytes * 2;\n  let temp = value;\n  // 检查长度是否正确，确保数据准确性\n  if (value.length > targetLength) {\n    // 提示值长度过长\n    emitLog({\n      type: 'warning',\n      message: `属性【${name}】转化后的值${value}长度过长，超过${bytes}个字节`,\n      data: { [name]: value },\n    });\n    temp = value.slice(0, targetLength);\n  } else if (value.length < targetLength) {\n    // 提示值长度过短\n    emitLog({\n      type: 'warning',\n      message: `属性【${name}】转化后的值${value}长度过短，少于${bytes}个字节`,\n      data: { [name]: value },\n    });\n    temp = padStart(value, targetLength, '0');\n  }\n  return formatValueByStorage(temp, storageType);\n};\n\nexport const formatCustom = (value: any, config: DpMapItem, res: any) => {\n  const { format, name } = config;\n  let temp = value?.toString();\n  if (typeof format === 'function') {\n    temp = format(value);\n  } else {\n    // 提示反解析方法未设置或不正确\n    emitLog({\n      type: 'warning',\n      message: `属性【${name}】为自定义类型，检测到未配置 format 处理函数`,\n      data: { [name]: value },\n    });\n  }\n  return formatString(temp, config, res);\n};\n\nexport const formatNumberBySeparate = (num: number, config: DpMapItem, res: any) => {\n  const { extension, numType = 'hex', storageType = 'be' } = config;\n  const bytes = getBytes(config, res);\n  let value = num % 10 ** (bytes * 2);\n  if (extension) {\n    const { min = -Infinity, max = Infinity } = extension;\n    value = Math.max(Math.min(value, max), min);\n  }\n  const result: string[] = [];\n  // 根据字节数，分隔数据\n  for (let i = 0; i < bytes; i++) {\n    const baise10 = 10 ** ((bytes - 1 - i) * 2);\n    const temp = Math.floor(value / baise10);\n    const text = numType === 'dec' ? formatTo10(temp, 1) : formatTo16(temp, 1);\n    value = value % baise10;\n    if (storageType === 'le') {\n      result.splice(0, 0, text);\n    } else {\n      result.push(text);\n    }\n  }\n\n  return result.join('');\n};\n","import { get } from 'lodash';\nimport { transformEnabled } from './condition';\nimport {\n  formatBit,\n  formatBoolean,\n  formatCustom,\n  formatEnum,\n  formatNumber,\n  formatNumberBySeparate,\n  formatString,\n  formatWeek,\n} from './formatFun';\nimport { getItemDefault } from './utils';\n\nconst formatFuns = {\n  number: formatNumber,\n  string: formatString,\n  boolean: formatBoolean,\n  bit: formatBit,\n  week: formatWeek,\n  enum: formatEnum,\n  custom: formatCustom,\n  numberBySeparate: formatNumberBySeparate,\n  default: formatNumber,\n};\n\n/**\n *\n * @param data 数据\n * @param rootData 根数据\n * @param config 配置\n * @param result 结果\n * @returns 结果存放\n */\nconst transformProp = (data: any, rootData: any, config: DpMapItem) => {\n  const { type = 'number', name, childMap, loop = false, limit } = config;\n  let max = 1;\n  let list: any = data[name] ?? getItemDefault(config, data);\n  // 处理循环情况\n  if (loop) {\n    // 是否限制循环次数\n    if (limit) {\n      // 是否由已解析的数据确认循环次数\n      if (typeof limit === 'string' || Array.isArray(limit)) {\n        max = get(data, limit, 0);\n      } else {\n        max = limit;\n      }\n    } else {\n      max = list.length;\n    }\n  } else {\n    list = [list];\n  }\n  const result: string[] = [];\n  for (let i = 0; i < max; i++) {\n    const itemValue = list[i] ?? getItemDefault(config, data);\n    let value: any;\n    // 如果是子类型解析\n    if (type === 'child') {\n      value = transform(itemValue, rootData, childMap);\n    } else {\n      // 其他数据类型处理\n      if (typeof formatFuns[type] === 'function') {\n        // @ts-ignore\n        value = formatFuns[type](itemValue, config);\n      } else {\n        value = formatFuns.default(itemValue, config, data);\n      }\n    }\n\n    result.push(value);\n  }\n\n  return result.join('');\n};\n\nconst transform = (data: any, rootData: any, dpMap: DpMap) => {\n  const result: string[] = [];\n  dpMap.forEach(itemConfig => {\n    const { condition } = itemConfig;\n    if (transformEnabled(condition, rootData, data)) {\n      // 执行解析\n      result.push(transformProp(data, rootData, itemConfig));\n    }\n  });\n  return result.join('');\n};\n\nexport const format = (data: any, dpMap: DpMap) => {\n  // raw格式数据必须有下发1字节数据，不能传空数据\n  if (Array.isArray(data) && dpMap[0]?.type === 'child' && dpMap[0]?.loop) {\n    return '00';\n  }\n  return transform(data, data, dpMap);\n};\n","import { parse } from './core/parse';\nimport { format } from './core/format';\nimport { onLog, offLog } from './core/log';\n\nexport default {\n  parse,\n  format,\n  onLog,\n  offLog,\n};\n"],"names":["callbacks","emitLog","data","_a","process","env","NODE_ENV","console","warn","message","forEach","cb","getItemDefault","config","result","defaultValue","type","extension","length","getBytes","min","padStart","range","Array","isArray","keys","map","res","bytes","let","temp","get","parseNumber","generator","value","nextNumber","max","Infinity","Math","parseBit","nextBits","TransformError","constructor","code","msg","this","ALLREADY_TO_END","UNKOWN_CONDITION","conditionOperate","condition","currentResult","operation","target","findType","prop","transformEnabled","conditions","some","cond","every","parseTypes","number","string","next","boolean","nextBoolean","bit","week","slice","enum","name","enumValue","includes","custom","parse","num","parseInt","numberBySeparate","numType","total","i","default","transformChild","rootResult","childMap","childResult","itemConfig","transformProp","loop","limit","values","hasNext","push","transform","dpValue","_b","ganerator","start","substr","isEnd","storageType","done","splice","join","Boolean","bitType","radix","bits","toString","split","v","Number","reverse","formatTo16","formatTo10","formatValueByNumType","formatValueByStorage","formatNumber","formatBit","end","byteBits","moreCount","j","formatString","targetLength","formatFuns","format","pow","baise10","floor","text","rootData","dpMap","list","itemValue","index","onLog","offLog","indexOf"],"mappings":"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"}